(define (an-integer-between a b)
  (require (<= a b))
  (amb a (an-integer-between (+ a 1) b)))


(define (eight-queens board-size)
  (let ((board (list))
        (sizeof (lambda (board) (- board-size (length board))))
        (make-queen (lambda (row col) (list row col)))
        (row-of (lambda (queen) (car queen)))
        (col-of (lambda (queen) (cadr queen)))
        (queens-of (lambda (board) board)))
    (define (a-potential-queen board)
      (let ((size (sizeof board)))
        (let ((max-row size)
              (max-col size))
          (let ((row (an-integer-between (+ (- board-size max-row) 1) board-size)))
            (let ((col (an-integer-between (+ (- board-size max-col) 1) board-size)))
              (make-queen row col))))))
    (define (collides-with? queen rest-of-queens)
      (define (collides? queen1 queen2)
        (define (diagonal-collides? q1 q2)
          (let ((diff (- (row-of q1) (row-of q2))))
            (if (and (= (- (row-of q1) diff) (row-of q2)) (= (- (col-of q1) diff) (col-of q2)))
                true
                false)))
        (cond ((eq? (row-of queen1) (row-of queen2)) true)
              ((eq? (col-of queen1) (col-of queen2)) true)
              ((diagonal-collides? queen1 queen2) true)
              (else false)))
      (cond ((null? rest-of-queens) false)
            ((collides? queen (car rest-of-queens)) true)
            (else (collides-with? queen (cdr rest-of-queens)))))
    (define (queens size)
      (if (= size 0)
          board
          (let ((new-queen (a-potential-queen board)))
            (display new-queen)(display " ")(display board)(newline)
            (require (not (collides-with? new-queen (queens-of board))))
            (set! board (cons new-queen board))
            (queens (- size 1)))))
    (queens board-size)))
