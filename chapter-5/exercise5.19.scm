(define (make-breakpoint label n)
  (let ((counter (make-breakpoint-counter n)))
    (define (dispatch m)
      (cond ((eq? m 'label) label)
            ((eq? m 'n) n)
            ((eq? m 'start-countdown) (counter 'start-counting))
            ((eq? m 'notify-advance) (counter 'tick))
            ((eq? m 'notify-current-instruction-count)
             (lambda (count)
               (define (inner n)
                 (if (= n 0)
                     'done
                     (begin
                      (counter 'tick)
                      (inner (- n 1)))))
               (counter 'start-counting)
               (inner count)))
            ((eq? m 'at-breakpoint?) (eq? (counter 'status) 'done))
            ((eq? m 'notify-leave) (counter 'reset))
            (else (error "Invalid message - MAKE-BREAKPOINT" m))))
    dispatch))

(define (make-breakpoint-counter n)
  (let ((count 0)
        (counting? 'no))
    (define (dispatch m)
      (cond ((eq? m 'start-counting)
             (set! count n)
             (set! counting? 'yes))
            ((eq? m 'tick)
             (if (eq? counting? 'yes)
                 (set! count (- count 1))))
            ((eq? m 'count) count)
            ((eq? m 'status)
             (if (and (eq? counting? 'yes) (= count 0))
                 'done
                 'counting-down))
            ((eq? m 'reset)
             (set! counting? 'no))
            (else
             (error "Not a valid message -- MAKE-BREAKPOINT-COUNTER" m))))
    dispatch))

(define (set-breakpoint machine label n)
  ((machine 'add-breakpoint) label n))

(define (cancel-breakpoint machine label n)
  ((machine 'remove-breakpoint) label n))

(define (cancel-all-breakpoints machine)
  (machine 'remove-all-breakpoints))

 
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '())
        (instruction-count 0)
        (is-tracing false)
        (breakpoints '())
        (current-instruction-count 0)
        (current-label '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))
                 (list 'print-stack-statistics
                       (lambda () (stack 'print-statistics)))
                 ))
          (register-table
           (list (list 'pc pc) (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error "Multiply defined register: " name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (begin
               (allocate-register name)
               (lookup-register name)))))
      (define (initialize-any-breakpoints label)
        (define (lookup-bp bps)
          (cond ((null? bps) #f)
                ((eq? ((car bps) 'label) label)
                 ((car bps) 'start-countdown)
                 (lookup-bp (cdr bps)))
                (else (lookup-bp (cdr bps)))))
        (lookup-bp breakpoints))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                (if is-tracing
                    (begin
                      (if (not (null? (preceeding-label (car insts))))
                          (begin
                            (display (preceeding-label (car insts)))
                            (display ":")
                            (newline)
                            ))
                      (display "  ")
                      (display (instruction-text (car insts)))
                      (newline)))
                (if (not (null? (preceeding-label (car insts))))
                    (begin
                      (set! current-instruction-count 0)
                      (set! current-label (preceeding-label (car insts)))
                      (initialize-any-breakpoints (preceeding-label (car insts)))))
                (set! current-instruction-count (+ current-instruction-count 1))
                (for-each (lambda (bp)
                           (bp 'notify-advance)
                           (if (bp 'at-breakpoint?)
                               (begin
                                 (display "Reached breakpoint ")
                                 (display (bp 'label))
                                 (display " at instruction ")
                                 (display (bp 'n))
                                 (newline)
                                 (mini-interpreter dispatch)
                                 (bp 'notify-leave))))
                         breakpoints)
                (set! instruction-count (+ instruction-count 1))
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (sources register)
        (map
         (lambda (inst)
          (let ((exp (cddr (instruction-text inst))))
            (cond ((operation-exp? exp) exp)
                  (else (car exp)))))
         (filter
          (lambda (inst) (is-source? inst register))
          (dispatch 'get-instructions))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq) (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register) allocate-register)
              ((eq? message 'get-register) lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops) (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              ((eq? message 'get-instructions)    (sort (remove-duplicate-instructions the-instruction-sequence) alpha-order))
              ((eq? message 'get-entry-points)    (filter entry-point? (dispatch 'get-instructions)))
              ((eq? message 'get-saved-registers) (remove-duplicates (map (lambda (inst) (cadr (instruction-text inst)))))) 
              ((eq? message 'get-sources) sources)
              ((eq? message 'get-register-names) (map car register-table))
              ((eq? message 'trace-on) (set! is-tracing #t))
              ((eq? message 'trace-off) (set! is-tracing #f))
              ((eq? message 'trace-register)
               (lambda (reg-name)
                 (if (member reg-name (dispatch 'get-register-names))
                     (let ((reg ((dispatch 'get-register) reg-name)))
                       (reg 'trace-on)
                       (display "Now tracing register ")(display reg-name)
                       (newline))
                     (error "Register name not in machine-- TRACE-REGISTER" reg-name))))
              ((eq? message 'untrace-register)
               (lambda (reg-name)
                 (if (member reg-name (dispatch 'get-register-names))
                     (let ((reg ((dispatch 'get-register) reg-name)))
                       (reg 'trace-off)
                       (display "No longer tracing register ")(display reg-name)
                       (newline))
                     (error "Register name not in machine-- TRACE-REGISTER" reg-name))))
              ((eq? message 'get-instruction-count)
               (let ((old-count instruction-count))
                 (set! instruction-count 0)
                 old-count))
              ((eq? message 'add-breakpoint)
               (lambda (label n)
                 (let ((bp (make-breakpoint label n)))
                   (if (eq? current-label label)
                       ((bp 'notify-current-instruction-count) current-instruction-count))
                   (set! breakpoints (cons bp breakpoints)))))
              ((eq? message 'remove-breakpoint)
               (lambda (label n)
                (for-each (lambda (bp)
                          (if (and (eq? (bp 'label) label) (= (bp 'n) n))
                              (set! breakpoints (delete bp breakpoints))))
                         breakpoints)))
              ((eq? message 'remove-all-breakpoints)
               (set! breakpoints '()))
              (else (error "Unknown request -- MACHINE" message))))
      dispatch)))

(define (mini-interpreter machine)
  (let ((command (read)))
    (cond ((eq? (car command) 'get-register-contents)
           (let ((contents (get-register-contents machine (caddr command))))
             (display "Contents of ")
             (display (caddr command))
             (display " :")
             (display contents)
             (newline))
           (mini-interpreter machine))
          ((eq? (car command) 'set-register-contents)
           (set-register-contents! machine (caddr command) (cadddr command))
           (display "done")(newline)
           (mini-interpreter machine))
          ((eq? (car command) 'proceed-machine)
           'exit)
          ((eq? (car command) 'set-breakpoint)
           (set-breakpoint machine (caddr command) (cadddr command))
           (display "done")(newline)
           (mini-interpreter machine))
          ((eq? (car command) 'cancel-breakpoint)
           (cancel-breakpoint machine (caddr command) (cadddr command))
           (display "done")(newline)
           (mini-interpreter machine))
          ((eq? (car command) 'cancel-all-breakpoints)
           (cancel-all-breakpoints machine)
           (display "done")(newline)
           (mini-interpreter machine))
          (else
            (display "Unknown command. Try again.")
            (newline)
            (mini-interpreter machine)))))

