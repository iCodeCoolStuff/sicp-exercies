(define (clear! cell) (set-car! cell false))
(define (test-and-set! cell)
  (if (car cell) true (begin (set-car! cell true) false)))
(define (make-mutex)
  (let ((cell (list false)))
    (define (the-mutex m)
      (cond ((eq? m 'acquire)
	     (if (test-and-set! cell)
		 (the-mutex 'acquire))) ;retry
	    ((eq? m 'release) (clear! cell))))
    the-mutex))
(define (make-serializer)
  (let ((mutex (make-mutex)))
    (lambda (p)
      (define (serialized-p . args)
	(mutex 'acquire)
	(let ((val (apply p args)))
	  (mutex 'release)
	  val))
      serialized-p)))

(define (make-stack)
  (let ((elements '()))
    (define (len)
      (length elements))
    (define (insert-stack! element)
      (begin (set! elements (cons element elements))
	     'done))
    (define (delete-stack!)
      (if (= (len) 0)
	  (error "Cannot delete element when stack is empty")
          (let ((e (car elements)))
	    (begin (set! elements (cdr elements))
	      e))))
    (define (dispatch m)
      (cond ((eq? m 'insert!) insert-stack!)
	    ((eq? m 'delete!) delete-stack!)
	    ((eq? m 'length)  len)
	    (else (error "Unknown operation -- STACK" m))))
    dispatch))

(define (push stack element)
  ((stack 'insert!) element))

(define (pop stack)
  ((stack 'delete!)))

(define (len stack)
  ((stack 'length)))

(define (make-semaphore n)
  (let ((open-mutexes (make-stack))
	(closed-mutexes (make-stack)))
    (define (init-mutexes)
      (define (init-rec k)
	(if (> k 0)
	    (begin (push open-mutexes (make-mutex))
	           (init-rec (- k 1)))))
      (init-rec n))
    (define (acquire)
      (if (= (len open-mutexes) 0)
	  (error "All mutexes are used up -- ACQUIRE")
          (let ((m (pop open-mutexes)))
	    (push closed-mutexes m)
	    (m 'acquire))))
    (define (release)
      (if (= (len closed-mutexes) 0)
	  (error "No mutexes are currently used -- RELEASE")
          (let ((m (pop closed-mutexes)))
	    (push open-mutexes m)
	    (m 'release))))
    (define (dispatch m)
      (cond ((eq? m 'acquire) (acquire))
	    ((eq? m 'release) (release))
	    ((eq? m 'diag)    (list open-mutexes closed-mutexes))
	    (else (error "Unknown operation: MAKE-SEMAPHORE" m))))
    (init-mutexes)
    dispatch))

(define (make-semaphore-test-and-set n)
  (let ((cell (list n))
	(serializer (make-serializer)))
    (define (test-and-set-semaphore! cell)
      (if (= (car cell) 0) true (begin (set-car! cell (- (car cell) 1)) false)))
    (define (increment-unless-n! cell)
      (if (< (car cell) n)
          (set-car! cell (+ (car cell) 1))
	  'done))
    (define (the-semaphore m)
      (cond ((eq? m 'acquire)
	     (if (test-and-set-semaphore! cell)
	         (the-semaphore 'acquire))) ;retry
	    ((eq? m 'release)
	     (increment-unless-n! cell))))
    the-semaphore))
